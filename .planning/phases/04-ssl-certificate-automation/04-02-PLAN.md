---
phase: 04-ssl-certificate-automation
type: execute
---

<objective>
Implement certificate CRUD operations in NPMClient with comprehensive error handling.

Purpose: Extend NPMClient with Let's Encrypt certificate management methods, following the proven proxy host API client pattern from Phase 3.
Output: NPMClient with certificate_create, certificate_list, certificate_get, certificate_delete methods, plus workflow helper for cert creation + attachment.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ssl-automation/04-RESEARCH.md
@.planning/phases/04-ssl-certificate-automation/04-01-SUMMARY.md
@.planning/phases/03-proxy-host-management/03-02-SUMMARY.md
@src/npm_cli/api/client.py
@src/npm_cli/api/models.py
@src/npm_cli/api/exceptions.py
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Add certificate CRUD methods to NPMClient</name>
  <files>src/npm_cli/api/client.py, tests/test_npm_client_certificates.py</files>
  <test-first>
Test: NPMClient certificate methods with mocked httpx responses
Cases:
  - certificate_create(CertificateCreate) → POST /api/nginx/certificates → Certificate
  - certificate_list() → GET /api/nginx/certificates → list[Certificate]
  - certificate_get(cert_id) → GET /api/nginx/certificates/{id} → Certificate
  - certificate_delete(cert_id) → DELETE /api/nginx/certificates/{id} → None
  - certificate_create with connection error → NPMConnectionError
  - certificate_create with API error → NPMAPIError
  - certificate_create with invalid response → NPMValidationError
  </test-first>
  <action>
Add certificate methods to NPMClient class in src/npm_cli/api/client.py, following RESEARCH.md patterns:

1. Import Certificate models at top:
   from npm_cli.api.models import Certificate, CertificateCreate

2. Add methods to NPMClient class (after proxy host methods):

   def certificate_create(self, cert: CertificateCreate) -> Certificate:
       """Create Let's Encrypt certificate via NPM API.

       NPM delegates to Certbot internally for ACME protocol.
       Supports HTTP-01 and DNS-01 challenges.
       """
       response = self.request("POST", "/api/nginx/certificates", json=cert.model_dump(exclude_none=True))
       return Certificate.model_validate(response)

   def certificate_list(self) -> list[Certificate]:
       """List all certificates."""
       response = self.request("GET", "/api/nginx/certificates")
       return [Certificate.model_validate(c) for c in response]

   def certificate_get(self, cert_id: int) -> Certificate:
       """Get certificate by ID."""
       response = self.request("GET", f"/api/nginx/certificates/{cert_id}")
       return Certificate.model_validate(response)

   def certificate_delete(self, cert_id: int) -> None:
       """Delete certificate.

       WARNING: Deleting certificate attached to proxy hosts breaks those hosts.
       Caller should check certificate_id usage before deletion.
       """
       self.request("DELETE", f"/api/nginx/certificates/{cert_id}")

All methods use self.request() for automatic JWT authentication and error handling (NPMConnectionError, NPMAPIError, NPMValidationError).

Follow TDD: Write tests first with mocked httpx responses, verify they fail, then implement methods.
  </action>
  <verify>uv run pytest tests/test_npm_client_certificates.py -v passes all tests</verify>
  <done>NPMClient has 4 certificate methods with comprehensive error handling, all tests pass</done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Add certificate attachment workflow helper</name>
  <files>src/npm_cli/api/client.py, tests/test_npm_client_certificates.py</files>
  <test-first>
Test: Workflow helper combines certificate creation + proxy host attachment
Cases:
  - attach_certificate_to_proxy(domain, cert_create, ssl_forced=True) → creates cert, finds proxy by domain, updates with cert_id
  - attach_certificate_to_proxy with proxy not found → raises ValueError
  - attach_certificate_to_proxy with cert creation failure → propagates NPMAPIError
  </test-first>
  <action>
Add workflow helper method to NPMClient class:

def attach_certificate_to_proxy(
    self,
    domain: str,
    cert: CertificateCreate,
    ssl_forced: bool = True,
    hsts_enabled: bool = True
) -> tuple[Certificate, ProxyHost]:
    """Create certificate and attach to proxy host in one operation.

    Workflow:
    1. Create Let's Encrypt certificate
    2. Find proxy host by domain name
    3. Update proxy host with certificate_id and SSL settings

    Args:
        domain: Domain name to find proxy host
        cert: Certificate creation parameters
        ssl_forced: Enable HTTPS redirect (default: True)
        hsts_enabled: Enable HSTS header (default: True)

    Returns:
        Tuple of (created certificate, updated proxy host)

    Raises:
        ValueError: If proxy host not found for domain
        NPMAPIError: If certificate creation or proxy update fails
    """
    # 1. Create certificate
    created_cert = self.certificate_create(cert)

    # 2. Find proxy host by domain
    proxy_hosts = self.proxy_host_list()
    proxy = next((h for h in proxy_hosts if domain in h.domain_names), None)

    if not proxy:
        raise ValueError(f"Proxy host not found for domain: {domain}")

    # 3. Attach certificate to proxy host
    updated_proxy = self.proxy_host_update(
        host_id=proxy.id,
        updates=ProxyHostUpdate(
            certificate_id=created_cert.id,
            ssl_forced=ssl_forced,
            hsts_enabled=hsts_enabled,
            http2_support=True
        )
    )

    return created_cert, updated_proxy

This simplifies the common workflow from RESEARCH.md code examples.

Follow TDD: Write tests first, verify they fail, then implement method.
  </action>
  <verify>uv run pytest tests/test_npm_client_certificates.py::test_attach_certificate_to_proxy -v passes</verify>
  <done>Workflow helper combines cert creation + proxy attachment, all tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] uv run pytest tests/test_npm_client_certificates.py passes
- [ ] All certificate methods use self.request() for auth + error handling
- [ ] Certificate models imported and used correctly
- [ ] Workflow helper reduces common pattern to single method call
- [ ] uv run ruff check src/ passes (no linting errors)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- NPMClient has 4 certificate CRUD methods + 1 workflow helper
- Comprehensive error handling (NPMConnectionError, NPMAPIError, NPMValidationError)
- TDD workflow followed (RED → GREEN → REFACTOR)
- No linting errors
  </success_criteria>

<output>
After completion, create `.planning/phases/04-ssl-certificate-automation/04-02-SUMMARY.md`:

# Phase 4 Plan 2: Certificate API Client Methods Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description
- `path/to/another.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 04-03-PLAN.md (Certificate CLI Commands)
</output>
