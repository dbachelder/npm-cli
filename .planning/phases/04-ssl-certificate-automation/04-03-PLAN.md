---
phase: 04-ssl-certificate-automation
type: execute
---

<objective>
Implement complete certificate CLI with Rich-formatted output and proxy host integration.

Purpose: Provide user-friendly certificate management commands following the proven proxy CLI pattern from Phase 3, with end-to-end workflow for SSL automation.
Output: Full certificate CLI (create, list, show, delete) with Rich output, plus enhanced proxy commands supporting --certificate option.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ssl-automation/04-RESEARCH.md
@.planning/phases/04-ssl-certificate-automation/04-01-SUMMARY.md
@.planning/phases/04-ssl-certificate-automation/04-02-SUMMARY.md
@.planning/phases/03-proxy-host-management/03-03-SUMMARY.md
@src/npm_cli/cli/cert.py
@src/npm_cli/cli/proxy.py
@src/npm_cli/api/client.py
@src/npm_cli/api/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement certificate CLI commands</name>
  <files>src/npm_cli/cli/cert.py</files>
  <action>
Replace placeholder cert.py with complete certificate commands following RESEARCH.md and Phase 3 proxy CLI patterns:

1. Import required modules:
   from datetime import datetime, timezone
   from npm_cli.api.client import NPMClient
   from npm_cli.api.models import CertificateCreate
   from npm_cli.config import Settings
   from rich.table import Table
   from rich.panel import Panel

2. Implement commands:

   @app.command()
   def list() -> None:
       """List all SSL certificates with expiration status."""
       # Get client, call certificate_list()
       # Create Rich table with columns: ID, Domains, Provider, Expires, Days Left, Status
       # Color-code status: green (>30 days), yellow (7-30 days), red (<7 days)
       # Display "⚠️  EXPIRING SOON" for <30 days, "✓ Valid" otherwise

   @app.command()
   def create(
       domain: list[str] = typer.Option(..., "--domain", "-d", help="Domain names (first is primary, rest are SANs)"),
       email: str = typer.Option(..., "--email", "-e", help="Let's Encrypt registration email"),
       name: str | None = typer.Option(None, "--name", "-n", help="Human-readable certificate name"),
       dns_provider: str | None = typer.Option(None, "--dns-provider", help="DNS provider for DNS-01 challenge (cloudflare, route53, etc.)"),
       dns_credentials: str | None = typer.Option(None, "--dns-credentials", help="DNS provider credentials (format: 'key = value')"),
       propagation_seconds: int = typer.Option(30, help="DNS propagation delay for DNS-01 challenges")
   ) -> None:
       """Create new Let's Encrypt certificate."""
       # Build meta dict with letsencrypt_email, optional dns_provider/credentials
       # Call certificate_create(CertificateCreate(...))
       # Display Rich panel with certificate details (ID, domains, expiration)
       # Remind user to attach to proxy host or use "npm-cli proxy update --certificate <id>"

   @app.command()
   def show(identifier: str = typer.Argument(help="Certificate ID or domain name")) -> None:
       """Show certificate details."""
       # Accept ID (numeric) or domain (string) like proxy show command
       # If domain: list certs, filter by domain_names, warn if multiple matches
       # Display Rich panel with: ID, domains, provider, created, expires, days left, status
       # Include "Attached to proxy hosts:" section listing proxy hosts using this cert

   @app.command()
   def delete(
       cert_id: int = typer.Argument(help="Certificate ID to delete"),
       force: bool = typer.Option(False, "--force", "-f", help="Skip usage check and confirmation")
   ) -> None:
       """Delete certificate with safety checks."""
       # If not force: check proxy hosts for certificate_id usage (safe_certificate_delete pattern from RESEARCH.md)
       # If in use: error with list of proxy hosts using cert
       # If force or not in use: prompt for confirmation (Typer.confirm())
       # Call certificate_delete(cert_id)
       # Display success message

Use Rich console.print() for all output (not print()), follow Phase 3 proxy CLI formatting patterns.

Error handling: wrap API calls in try/except for NPMConnectionError, NPMAPIError, NPMValidationError with helpful messages.
  </action>
  <verify>uv run npm-cli cert --help shows all commands, each command has proper help text</verify>
  <done>Certificate CLI has 4 commands (list, create, show, delete) with Rich formatting and comprehensive error handling</done>
</task>

<task type="auto">
  <name>Task 2: Add --certificate option to proxy commands</name>
  <files>src/npm_cli/cli/proxy.py</files>
  <action>
Enhance proxy create and update commands to support certificate attachment:

1. Add to proxy create command:
   --certificate: int | None = typer.Option(None, "--certificate", "-c", help="Attach SSL certificate by ID")
   --ssl-forced: bool = typer.Option(False, "--ssl", help="Force HTTPS redirect (requires --certificate)")

   If --certificate provided: set certificate_id and ssl_forced in ProxyHostCreate
   If --ssl-forced without --certificate: error "SSL force requires certificate"

2. Add to proxy update command:
   --certificate: int | None = typer.Option(None, "--certificate", "-c", help="Attach SSL certificate by ID")
   --ssl-forced: bool | None = typer.Option(None, "--ssl/--no-ssl", help="Enable/disable HTTPS redirect")

   Include in ProxyHostUpdate if provided

This enables workflows like:
  npm-cli cert create -d example.com -e admin@example.com  # Returns ID 5
  npm-cli proxy update example.com --certificate 5 --ssl

Or combined:
  npm-cli proxy create -d app.example.com -f http://localhost:3000 -p 80 --certificate 5 --ssl
  </action>
  <verify>uv run npm-cli proxy create --help shows --certificate and --ssl options with descriptions</verify>
  <done>Proxy commands support --certificate option for SSL integration, validation prevents invalid flag combinations</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete certificate CLI with create, list, show, delete commands and proxy host SSL integration</what-built>
  <how-to-verify>
Test certificate workflow against live NPM instance:

1. List certificates: `uv run npm-cli cert list`
   - Verify table shows existing certificates
   - Check expiration status color-coding
   - Confirm no errors

2. Create certificate (HTTP-01): `uv run npm-cli cert create -d test-$(date +%s).example.com -e admin@example.com -n "Test Cert"`
   - NOTE: Replace example.com with a domain you control for actual certificate issuance
   - OR test with existing proxy host domain
   - Verify certificate creation succeeds
   - Note the certificate ID

3. Show certificate: `uv run npm-cli cert show <cert-id>` or `uv run npm-cli cert show test-*.example.com`
   - Verify detailed panel displays
   - Check domain lookup works
   - Verify "Attached to proxy hosts" section

4. Attach to proxy host: `uv run npm-cli proxy update <existing-proxy-domain> --certificate <cert-id> --ssl`
   - Use an existing test proxy host
   - Verify SSL attachment succeeds
   - Check `uv run npm-cli proxy show <domain>` displays certificate info

5. Delete certificate (safe): `uv run npm-cli cert delete <cert-id>`
   - If attached: verify error message lists proxy hosts using cert
   - If not attached: verify confirmation prompt
   - Test `--force` flag bypasses checks

6. Error handling: Test with invalid inputs
   - Non-existent certificate ID → helpful error
   - Missing required fields → validation error with guidance
   - Connection issues → clear error message

Expected: All commands work correctly, Rich formatting displays properly, error messages are helpful, certificate attachment workflow is smooth.
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] uv run pytest passes (all existing tests still work)
- [ ] uv run ruff check src/ passes (no linting errors)
- [ ] Certificate CLI commands produce Rich-formatted output
- [ ] Proxy commands support --certificate option
- [ ] Safe certificate deletion checks usage before deleting
- [ ] Manual verification checkpoint passed
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Certificate CLI has 4 commands (list, create, show, delete)
- Proxy CLI enhanced with --certificate option
- Rich formatting for all certificate output
- Comprehensive error handling with helpful messages
- End-to-end SSL workflow verified against live NPM
- Phase 4 complete - SSL Certificate Automation functional
  </success_criteria>

<output>
After completion, create `.planning/phases/04-ssl-certificate-automation/04-03-SUMMARY.md`:

# Phase 4 Plan 3: Certificate CLI Commands Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description
- `path/to/another.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Deviations from Plan

[Auto-fixed issues, enhancements beyond plan, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

**Phase 4 complete!** SSL Certificate Automation fully implemented and verified.

Ready for Phase 5: Configuration Templates

Dependencies met:
- ✓ Certificate CRUD operations via NPM API
- ✓ Let's Encrypt integration through NPM/Certbot
- ✓ Certificate attachment to proxy hosts
- ✓ Rich CLI output for certificate management
- ✓ Comprehensive error handling
- ✓ End-to-end SSL workflow verified

Learnings for Phase 5:
- [Key learnings from implementation]
- [Patterns to maintain]
- [API quirks discovered]

---
*Phase: 04-ssl-certificate-automation*
*Completed: [date]*
</output>
